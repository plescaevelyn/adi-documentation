Just Enough Software and HDL for High-Speed Designs
===================================================

This workshop goes through the software tools typically used 
when working with the ADALM Pluto board, demonstrating its versatility 
and showing hands-on exercises to get you up and running quickly.

This workshop was first presented at the 2023 FTC by Mihai Bancisor and Michael Hennerich.

Slide Deck and Booklet
----------------------

Since this tutorial is also designed to be presented as a live, hands-on
workshop, a slide deck is provided here:

.. admonition:: Download

   :download:`SDR Lab Slide Deck <Train_Just enough Software and HDL for High Speed designs.pdf>`

A complete booklet of the hands-on activity is also provided, as a companion to
following the tutorial yourself:

.. admonition:: Download

   :download:`SDR Lab Booklet <instructions_sdr_lab.pdf>`

The source code for the hands-on exercises is provided here:

.. admonition:: Download

   :download:`SDR Lab Source Code <workshop_exercises.zip>`

.. The SD Card image for the hands-on exercises is provided here:
.. 
.. .. admonition:: Download
.. 
..    :download:`SDR Lab Image <SDR_Lab_Image.zip>`

.. contents:: Workshop Contents
   :local:
   :depth: 3


Prerequisites
~~~~~~~~~~~~~

**Hardware Requirements**:

* ADALM-PLUTO SDR board
* USB cable (provided)
* SMA cables for loopback connections (provided)
* Two antennas for wireless experiments (provided)
* PC/Laptop with USB port

**Software Requirements**:

The workshop SD card image provides all necessary software pre-installed. If setting up your own environment, you will need:

* Python 3.7 or newer
* PyADI-IIO library
* GNU Radio 3.8 or newer with gr-iio blocks
* IIO Oscilloscope (optional, for visualization)
* libiio library

**Recommended Background Knowledge**:

* **Basic DSP Concepts**: 
  
  * Understanding of sampling, frequency, and time domain
  * Familiarity with I/Q (In-phase/Quadrature) signals
  * Basic knowledge of filtering

* **Programming**:
  
  * Basic Python programming skills
  * Familiarity with NumPy and Matplotlib is helpful

* **Communications Fundamentals**:
  
  * Understanding of modulation concepts
  * Basic radio frequency (RF) concepts

**Prior experience with GNU Radio or MATLAB is helpful but not required.** The workshop provides step-by-step instructions for all exercises.


Learning Objectives
~~~~~~~~~~~~~~~~~~~

By the end of this workshop, you will have a solid understanding of:

#. Typical Customer Design Flow
#. Software in the Design-in Journey
#. Evaluation, Test and Analysis
#. Algorithmic Development, Modeling and Prototyping
#. Building Blocks for development and new revenue streams
#. Common Architecture patterns used for easy transition between platforms

Analysis, control and evaluation tools
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#. (ACE) Software
#. IIO Oscilloscope
#. Scopy
#. qIQ Receiver
#. MATLAB Simulink

Hands-on exercises
~~~~~~~~~~~~~~~~~~

TODO: Complete

Theoretical Concepts and Practical Foundations
----------------------------------------------

Typical Customer Design Flow
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Software-defined radio development follows a progressive, stage-based approach that takes designs from initial research through to production deployment. 
The key advantage of ADI's approach is that the **same HDL, software, and infrastructure components are used throughout the entire flow**, 
reducing the learning curve and development risk at each stage.

.. figure:: images/customer_design_flow.png
   :alt: Customer Design Flow
   :align: center

   Typical Customer Design Flow

The typical customer design flow consists of 5 progressive stages, each building upon the previous one.

In the **research** phase, engineers validate that the chosen ADI device meets application requirements through simulation and measurement. 

Key activities include:

* **Behavioral Simulation**: Model the system before building hardware
* **Device Evaluation**: Test actual hardware performance using evaluation boards
* **Measurements**: Characterize critical performance metrics such as SFDR (Spurious-Free Dynamic Range), SNR (Signal-to-Noise Ratio), EVM (Error Vector Magnitude), NF (Noise Figure), and NSD (Noise Spectral Density)

Tools used: Evaluation boards, IIO Oscilloscope, ACE software, bench test equipment.

During the **Algorithm Development** phase, engineers implement signal processing algorithms using high-level languages while streaming real data from hardware.
Here, the focus is on rapid prototyping and validation of algorithms in realistic conditions via **MATLAB/Python/GRC Reference Implementation**, **Hardware Streaming**, 
and **Iterative Development**.

Development environments at this stage include MATLAB/Simulink with ADI toolboxes, Python with PyADI-IIO, GNU Radio Companion with gr-iio blocks.

The **Design Elaboration** phase refines algorithms for embedded deployment through modeling and optimization. This stage include modeling using the same
development tools, validating optimized algorithms with real hardware data, and transitioning from floating-point to fixed-point arithmetic 
for efficient hardware implementation.

Critical considerations include fixed-point precision, filter coefficient quantization, timing budgets, and FPGA resource utilization.

While *prototyping*, algorithms are deployed to development hardware for integration and optimization. This stage includes:

* **Deployment to Development Board**: Move algorithms to actual hardware (PlutoSDR, Jupiter, or FMC boards)
* **Design Optimization**: Tune for performance and resource efficiency
* **HDL Integration**: Integrate custom signal processing with ADI reference designs

The final stage, **Production**, includes deployment to custom hardware with complete system validation.

Throughout all stages, the same HDL IP cores, Linux kernel drivers, and application software are reused, dramatically reducing development risk and time-to-market.


Software in the Design-in Journey
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ADI's software ecosystem provides a cohesive solution across the entire design-in journey, supporting multiple development environments 
while maintaining a common underlying infrastructure. The ecosystem enables engineers to work in their preferred tools—whether GUI-based applications, 
scripting environments, or modeling platforms—all leveraging the same drivers, libraries, and hardware abstraction layers.

**Common Software Infrastructure:**

* **libiio**: Cross-platform library providing unified hardware access
* **IIO Kernel Drivers**: Linux drivers for ADI converters and transceivers
* **iiod Server**: Network-transparent access to hardware
* **Language Bindings**: Support for C, C++, Python, MATLAB, and more

**Development Tools and Environments:**

* **IIO Oscilloscope**: GUI application for quick visualization and device control
* **MATLAB/Simulink**: ADI toolboxes for algorithm development and modeling
* **Python/Jupyter**: PyADI-IIO library with NumPy/SciPy integration
* **GNU Radio**: gr-iio blocks for flowgraph-based development
* **ACE Software**: Analysis, Control, and Evaluation tools
* **Scopy**: Advanced measurement and analysis platform


Evaluation, Test and Analysis
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Analog Devices provides a single cohesive software solution, meeting customers in their ecosystem or at their tools of choice.

.. figure:: images/sw_solution.png
   :alt: Software Solution Architecture
   :align: center

   Single cohesive software solution supporting multiple user personas and tools

** Product Evaluation** uses hardware and software tools to verify that the Converter meets Application requirements.

Time investment is (very roughly) proportional to complexity and how application specific it needs to be

**Tools:** IIO Oscilloscope, ACE software, Scopy, bench test equipment


Algorithmic Development, Modeling and Prototyping
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Product Prototyping** provides Plug 'n' Play hardware and software to see the key features and performance of the part.

It can configure, capture signals, or generate waveforms in 10-15 minutes, stream real data from hardware into development 
environments (MATLAB, Python, GNU Radio) and develop and validate algorithms with hardware-in-the-loop

**Development Environments:** MATLAB/Simulink, Python/PyADI-IIO, GNU Radio Companion

**Tools:** MATLAB/Simulink, Python/PyADI-IIO, GNU Radio


Building Blocks for Development and New Revenue Streams
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ADI's modular architecture provides reusable building blocks that accelerate development and create opportunities for new applications and revenue streams.

.. figure:: images/building_blocks.png
   :alt: Building Blocks for Development
   :align: center

Modular building blocks enable rapid development and platform scalability. Signal processing components including filters, decimators, interpolators, 
and other DSP primitives are standard offerings that accelerate algorithm implementation. Protocol implementations such as OFDM, QPSK, and FSK 
are pre-implemented for rapid deployment, while pre-validated HDL provides high-performance streaming and buffering for demanding applications.

Efficient clock and power distribution features enable portable and battery-powered applications. Multiple libraries and frameworks provide flexible 
hardware access and algorithm development: PyADI-IIO for rapid Python prototyping with hardware-in-the-loop, MATLAB and Simulink toolboxes for system-level 
modeling and deployment, GNU Radio gr-iio blocks for flowgraph-based signal processing, and standardized Linux drivers that reduce integration effort.

The business benefits are compelling. Faster time-to-market results from pre-validated components that reduce development cycles, while proven building 
blocks minimize integration challenges and eliminate redundant design work through IP reuse. Platform scalability allows you to start with ADALM-PLUTO 
and scale seamlessly to production platforms.

Revenue opportunities emerge through application-specific solutions for vertical markets, proprietary algorithm development, custom hardware transitions 
with unified software stacks, and IP licensing of optimized implementations.

Common Architecture for Easy Platform Transition
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The common architecture across ADI's platforms makes it easy to transition between hardware as your project evolves from prototype to production.

.. figure:: images/common_architecture.png
   :alt: Common Architecture Makes It Easy to Transition Between Platforms
   :align: center

   Common architecture enables seamless transitions between platforms

**Shared Software and HDL Stack:**

* **Same libraries**: libiio, PyADI-IIO, and hardware drivers work across all platforms
* **Common Linux image**: ADI Kuiper Linux brings up the same software stack whether on a laptop or embedded board
* **Unified HDL**: Common FPGA designs across all SDR platforms
* **Consistent drivers**: Same drivers whether accessing hardware locally or via USB

**Platform Progression:**

* **Start with ADALM-PLUTO**: Provides quick verification, rapid algorithm development, and SIGINT applications at very low cost
* **Scale to production**: Same software and HDL seamlessly transfer to higher-performance platforms
* **Use modules for clean design**: Leverage ADI's reference designs and IP cores

**Open Source Repositories:**

* Common Linux kernel and drivers: https://github.com/analogdevicesinc/linux
* Common HDL IP cores: https://github.com/analogdevicesinc/hdl

This architecture ensures that code developed on entry-level hardware like ADALM-PLUTO can be reused on production platforms with minimal changes, dramatically reducing development risk and time-to-market.

Analysis | Control | Evaluation
-------------------------------

TODO: Complete


Hands on exercises
------------------

#. Transmit and receive a complex sinusoid  with Python and Pluto SDR

   A complex sinusoid is a fundamental building block in software-defined radio. Unlike a real sinusoid 
   (which oscillates in a single dimension), a complex sinusoid consists of two components:
   
   * **In-phase (I) component**: Real part of the signal
   * **Quadrature (Q) component**: Imaginary part of the signal
   
   Together, they form a single tone in the frequency domain. This exercise transmits a complex sinusoid 
   at 20 kHz and receives it back via a loopback connection, allowing you to observe both the transmitted 
   signal and its frequency spectrum representation.

   ..figure:: images/exercises/sinewave_loopback/complex_sinusoid.png
      :alt: Complex Sinusoid
      :align: center

      Complex sinusoid with in-phase (I) and quadrature (Q) components

   ..figure:: images/exercises/sinewave_loopback/complex_sinusoid_constellation_plot.png
      :alt: Complex Sinusoid Constellation Plot
      :align: center

      Constellation plot of a complex sinusoid

   Follow the next steps:

   #. Make the following setup using Pluto and connect it to your PC:
   
    .. figure:: images/exercises/sinewave_loopback/pluto_setup.png
       :alt: Pluto SDR Setup
       :align: center

       Pluto SDR setup with loopback connections

   #. Download the SDR Lab Source Code from the link above and unzip it on your desktop.

   #. Open **workshop_exercises** folder on your desktop.

   #. Go to **python->sinewave_loopback** subfolder.

   #. Right click on **python_loopback_sine_pluto.py -> Open with Other Application** and 
   select **Thonny Python IDE** (or any other Python IDE you have installed) from the 
   Recommended Applications list.

   .. figure:: images/exercises/sinewave_loopback/python_ide.png
      :alt: Open Python Script with IDE
      :align: center

      Open the Python script with Thonny Python IDE

   # To run the script, press the green round button from the top left corner in Thonny IDE as shown below.

   ..figure:: images/exercises/sinewave_loopback/run_script.png
      :alt: Run Python Script
      :align: center

      Run the Python script in Thonny IDE

   # To zoom on a plot, you can use the zoom option as depicted below. Encircle holding left click the area you want to zoom. 
   On this example, if you zoom at the figure below on the received signal, you should see a harmonic at 20KHz.

   .. figure:: images/exercises/sinewave_loopback/zoom_plot.png
      :alt: Zoom on Plot
      :align: center

      Zoom on the plot to see the harmonic at 20KHz

   # To stop running the python script (if you want to run it again or run another script), close all the tabs by **right clicking on the
   taskbar icon -> Quit x windows** as shown depicted below or close them manually one by one.

   .. figure:: images/exercises/sinewave_loopback/close_tabs.png
      :alt: Close Tabs
      :align: center

      Close all tabs to stop the Python script 